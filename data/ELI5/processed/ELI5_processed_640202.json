{"topic":{"0":"N\/A","1":"N\/A","2":"N\/A","3":"N\/A","4":"N\/A","5":"N\/A","6":"N\/A","7":"N\/A","8":"N\/A"},"dialog_lvl":{"0":"eli5","1":"eli5","2":"eli5","3":"eli5","4":"eli5","5":"eli5","6":"eli5","7":"eli5","8":"eli5"},"role":{"0":"Explainee","1":"Explainer","2":"Explainee","3":"Explainer","4":"Explainee","5":"Explainer","6":"Explainee","7":"Explainer","8":"Explainee"},"turn_num_tokens":{"0":8,"1":41,"2":93,"3":103,"4":25,"5":14,"6":50,"7":61,"8":67},"turn":{"0":"ELI5 - Halting Problem and the Self-Referential Proof","1":"Since minds have descriptions, and those descriptions can be used to simulate other minds, she can simulate me and what I will say about her behavior. In this case she simulates what I would say given a description of her mind.","2":"I don't understand how this is a proof of anything.  It's possible of course that I'm hopelessly lost and always will be--after all, not everything can be explained adequately to an idiot (I'm counting myself as an idiot for present purposes)--but my understanding of computers is that they're deterministic.  So how can it be that, in the \"proof,\" the program is permitted to change course to foil the oracle?  That doesn't seem to mimic how computers actually work, and thus seems to have one or more flaws as a proof.","3":"Let me see if I can phrase the formal proofs others have given.  A program H claims to be able to solve the halting problem. This program has some code, which I'll call \"code of H\".  Now, I'm going to write a program called P, which looks like the following.      put its source code into \"code of P\"          simulate \"code of H\" with \"code of P\" as the input      if the simulation says \"code of P\" should halt, loop      if the simulation says \"code of P\" should loop, halt","4":"Are \"code of H\" and \"H\" to be treated as equivalents for the purpose of showing that \"H\" is wrong in at least one instance?","5":"Yes - the text \"code of H\" fully describes how the program H behaves.","6":"But does \"code of H\" include the input?  I was thinking the input and source code are separate things, and that \"H\" describes both the input (i.e., what the program evaluates or does) and the source code (i.e., how the program carries out instructions).  Am I missing something?","7":"Commonly used abstract models of computation, as well as actual computers, draw a distinction between programs and memory. The program itself never changes, while the memory can change as the program runs. The program is inherently a set of instructions which manipulate memory.  The input is never a part of the program itself. Inputs are placed in memory when a program runs.","8":"That much, as far as it goes, makes sense to me.  For example, when I draft a document using Microsoft Word, I'm not making changes to the source code of Word as I draft or save a document.  I'm making changes to a \"document,\" which is simply something that's being stored somewhere in my machine and which I manipulate using Word.  Word never \"changes.\""}}