{"topic":{"0":"N\/A","1":"N\/A","2":"N\/A","3":"N\/A","4":"N\/A","5":"N\/A","6":"N\/A","7":"N\/A","8":"N\/A","9":"N\/A","10":"N\/A","11":"N\/A","12":"N\/A","13":"N\/A","14":"N\/A","15":"N\/A","16":"N\/A","17":"N\/A","18":"N\/A","19":"N\/A","20":"N\/A","21":"N\/A","22":"N\/A"},"dialog_lvl":{"0":"eli5","1":"eli5","2":"eli5","3":"eli5","4":"eli5","5":"eli5","6":"eli5","7":"eli5","8":"eli5","9":"eli5","10":"eli5","11":"eli5","12":"eli5","13":"eli5","14":"eli5","15":"eli5","16":"eli5","17":"eli5","18":"eli5","19":"eli5","20":"eli5","21":"eli5","22":"eli5"},"role":{"0":"Explainee","1":"Explainer","2":"Explainee","3":"Explainer","4":"Explainee","5":"Explainer","6":"Explainee","7":"Explainer","8":"Explainee","9":"Explainer","10":"Explainee","11":"Explainer","12":"Explainee","13":"Explainer","14":"Explainee","15":"Explainer","16":"Explainee","17":"Explainer","18":"Explainee","19":"Explainer","20":"Explainee","21":"Explainer","22":"Explainee"},"turn_num_tokens":{"0":8,"1":66,"2":56,"3":21,"4":27,"5":45,"6":122,"7":29,"8":116,"9":37,"10":64,"11":46,"12":6,"13":20,"14":58,"15":11,"16":108,"17":21,"18":82,"19":66,"20":47,"21":11,"22":3},"turn":{"0":"ELI5 - Halting Problem and the Self-Referential Proof","1":"Well, yes - H(a,b) is the Oracle, but the Oracle is a program, and a program is a list of instructions. Mystery instructions in this case.  P is a program that takes one input, and we just call that input x here. It's supposed to be a program, similarly to how a in H(a,b) is supposed to be a program.  Would you feel more comfortable calling it P(c)?","2":"But I don't understand what work the input to P does--it doesn't seem to figure into the subroutine or anything else about P--P seems to consist solely of the Oracle as a subroutine and then some instructions to do the opposite of whatever the result of the Oracle is.  What is the point of P(x)?","3":"Oh, P is just setup to do what we actually want to do, which is running P(P). How would P(P) behave?","4":"I'm not sure how P(p) would behave.  The self-reference is hard for me to parse.  And I'm not sure how to plug and chug it.","5":"Alright. Just to recap, P(x) means running H(x,x) and then acting in opposition to that.  So, **P(P)** runs H(P,P). This makes H simulate **P(P)** and look at whether that stops.  Just to make sure, another break here. This part is still clear? Note the parts I've bolded.","6":"I understand what P(x) means, I think.    P takes one argument (x)--although it's difficult to see how it actually USES it, I think it could be dropped entirely--and does the following:  It runs a subroutine involving Oracle (but I'm NOT sure that H(x,x) makes sense because Oracle takes two arguments, one is a program and other is input to that program--it strikes me as nonsensical to have Oracle take (x,x) as its arguments for that reason; it implies that the program and the input are the same thing) and based on the result that Oracle returns, P does the opposite.  I don't know what to make of your statement that \"P(P) runs H(P,P).\"   That makes absolutely no sense to me.","7":"P(P) = running P with argument P. This in turn runs H with arguments P and P (hence H(P,P)).  Remember that both H and P are essentially just instruction lists.","8":"I don't understand this.  Maybe I'm missing something about P.  Again, to reemphasize, here's what I understand P(x) to do.  Takes an argument (x)--although I still don't see what work the argument does, haven't seen an explanation of that--and does the following:  (1) Runs a subroutine with the Oracle--H(a, b) [This is why I don't think H(x, x) is correct--it implies that the program and input arguments are the same, and I don't think that's correct.]  (2) Looks at the result of the Oracle subroutine and then does the opposite; in other words, if Oracle returns HALT then P(x) loops forever and if Oracle returns LOOPS FOREVER then P(x) halts.  I still don't understand P(P) or, worse, H(P,P).","9":"No, H(x,x) is correct. It looks at x(x) and whether that stops.  For example, x could be a program that counts the number of instructions of another program. So x(x) would count how many instruction it itself has.","10":"OK, if it's H(x,x) in the subroutine, what was the purpose of defining it as H(a,b) in the first place?  I don't understand how the program could be the same as the input (i.e., what does H(x,x) even mean and how could it possibly work?)  I guess I'm hopelessly lost again.  Thinking about throwing in the towel on all of this.","11":"So as an example, S(t) could be \"Count how many words the sentence t has and add two.\" You could then look at S(S) and see that S has 11 words and so get 13 in total. Does such a program S make sense to you?","12":"No.  Not in the slightest.","13":"Hm. Then I'm out of ideas because I don't really understand what you don't understand. Sorry this didn't work out.","14":"I don't understand how H(a,b) got transformed into H(x,x) and why it needed to be transformed.  I don't understand how H(x,x) could be a thing.  I don't understand how P(P) could be a thing, or what it would look like (no explanation I've seen actually walks through what happens).  In short, feeding a program to itself makes no sense to me.","15":"Do you understand that H(a,b) and H(c,d) are the same thing?","16":"Yes, I understand that those are the same thing (or at least it's possible that they could be the same thing).  One thing that's tripping me up is how and why H(a,b)--which is still my lifeline here--got transformed to H(x,x) in the subroutine, and how H(x,x) could even be coherently evaluated.  Then the final (or maybe not final, I'm getting sleepy) difficulty is P(P).  Don't even understand how to begin understanding what that could entail (i.e., I don't understand how a program's only argument could be the program itself, or what it would do with that argument, not to mention the difficulty that P contains a subroutine with H(x,x)).","17":"So is the problem with H(x,x) just that both arguments are the same, or is it that it looks at x(x)?","18":"I don't know what looks at \"x(x)\" means.  I don't understand how H(a,b)--which makes sense to me--got transformed to H(x,x) in the subroutine, or why it had to be transformed.  Beyond that, I don't know how H(x,x) would work.  Or how the \"program\" and the \"input\" of H(a,b) could somehow be the same thing (which is what H(x,x) implies to me--if I've misunderstood that, please let me know).  And beyond that, I truly don't know how to process or think about P(P).","19":"Alright, so H(a,b) is when you describe what H does. You have to call them differently because they're different arguments, even if they could be the same.  H(x,x) is then running that routine with *specific* arguments. Essentially, it runs H(a,b), but with a=x and b=x. The cause of the transformation is that we're no longer looking at the definition of H, but at the application of H.","20":"Why does H(x,x) need to be run in the way it does?  And how is H(x,x) even a thing?  I still don't understand how a program and the input to the program (i.e., the two arguments for the subroutine) can be the very same thing.","21":"Hm I might be out of ideas trying to explain it...","22":"Updated the post."}}