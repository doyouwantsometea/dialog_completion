{"topic":{"0":"N\/A","1":"N\/A","2":"N\/A","3":"N\/A","4":"N\/A","5":"N\/A","6":"N\/A","7":"N\/A","8":"N\/A"},"dialog_lvl":{"0":"eli5","1":"eli5","2":"eli5","3":"eli5","4":"eli5","5":"eli5","6":"eli5","7":"eli5","8":"eli5"},"role":{"0":"Explainee","1":"Explainer","2":"Explainee","3":"Explainer","4":"Explainee","5":"Explainer","6":"Explainee","7":"Explainer","8":"Explainee"},"turn_num_tokens":{"0":8,"1":146,"2":148,"3":50,"4":124,"5":88,"6":74,"7":62,"8":81},"turn":{"0":"ELI5 - Halting Problem and the Self-Referential Proof","1":"To explain a bit further, the problem I see is in having M run P with input of M. You can have programs that output their own source code, but to explain construction of M one should get a bit further into details about how M can take this P and run it with full source of M as parameter. And while I think it probably can be done, proving that doesn't seem easy to me. And to explain it... uh, the bit I remember about programs that can print their source was that it wasn't easy to follow even for super simple cases. I don't even know how to phrase existence proofs for that sorta stuff.  Anyway, my two cents is that if you entertain that M existing seems plausible enough, proof works. If not, then the actual proof that sidesteps this is probably way easier.","2":"Yes, that is one area where I've been tripped up!    Other than defining it into existence and saying \"assume that this can work,\" I can't make sense of how the programs could possibly work together in the way conceived of in the pseudo-code proof.    And there's no explanation that I've found that actually runs through all of what ACTUALLY happens when they're thrown together in that way beyond \"gee whiz, when one says stop the other one loops and when one says loop the other one halts.\"  I don't see how that necessarily follows (although I can see how it makes sense intuitively to those who know how to code), and there's no step-by-step explanation that I've been able to find so far.  The actual proof, I imagine, involves a whole bunch of symbols (and resulting familiarity with set theory, etc.) that I couldn't possibly grasp.","3":"&gt; The actual proof, I imagine, involves a whole bunch of symbols  It's not super hard to understand. If you can understand Cantor's diagonalization argument, then it should be doable. There's also a little bit of interplay between programs and functions that might be a bit hard to follow at first.  https:\/\/en.wikipedia.org\/wiki\/Cantor%27s_diagonal_argument","4":"Thank you--but Cantor's diagonalization proof is something I've never been able to understand, either.  There are too many background principles with which I have no familiarity (I'm one of those people who'd say \"just add the number you've created to the list\"; I know that rejoinder is incorrect but I don't know why it is incorrect) for me to understand why diagonalization works as a proof.  I do think I understand what a proof by contradiction is supposed to do.  You start with an assumption:  \"P.\"  Then, through reasoning, you show that \"P\" leads to something that cannot be true (e.g., 2 + 2 = 0), therefore (assuming the steps hold) the initial assumption is the thing that cannot be true.","5":"&gt; (I'm one of those people who'd say \"just add the number you've created to the list\"  The assumption initially made was \"this list contains all the numbers\". No other assumptions. If you have to start adding numbers, then the list didn't contain all numbers, and you've proven that this assumption \"list with all numbers\" is impossible. Doesn't matter how clever you are, how many hours you spend adding exceptions you found, what you end up with is a list, and you've proven it won't contain all the numbers.","6":"My other rejoinder--and I know that it must be fallacious--would be that \"there must be a better way to generate a list containing all of the numbers, and my initial list wasn't generated optimally.\"  I don't know enough about math or set theory to know how or why Cantor's proof responds to that, although I trust that the proof works given how long it's been around and how many people have examined it.","7":"&gt;  \"there must be a better way to generate a list containing all of the numbers, and my initial list wasn't generated optimally.\"   The key is, no matter how you generated the list, how well thought-out it was, since diagonal argument assumes nothing of what's in the list or how it was made, the same argument still proves it's not complete.","8":"There are a lot of other assumptions built in, I think, that I don't know enough about to ask intelligent questions about them.  It makes intuitive sense to me that, given the way the so-called diagonal is generated, one could never produce a list that the diagonal couldn't defeat.  But there's probably some property of numbers that I'm missing in my intuitive \"acceptance\" of the diagonalization proof (e.g., I don't know what the relationship between \"reals\" and \"integers\" is)."}}