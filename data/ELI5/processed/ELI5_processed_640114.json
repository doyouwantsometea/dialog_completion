{"topic":{"0":"N\/A","1":"N\/A","2":"N\/A","3":"N\/A","4":"N\/A","5":"N\/A","6":"N\/A","7":"N\/A","8":"N\/A","9":"N\/A","10":"N\/A","11":"N\/A","12":"N\/A"},"dialog_lvl":{"0":"eli5","1":"eli5","2":"eli5","3":"eli5","4":"eli5","5":"eli5","6":"eli5","7":"eli5","8":"eli5","9":"eli5","10":"eli5","11":"eli5","12":"eli5"},"role":{"0":"Explainee","1":"Explainer","2":"Explainee","3":"Explainer","4":"Explainee","5":"Explainer","6":"Explainee","7":"Explainer","8":"Explainee","9":"Explainer","10":"Explainee","11":"Explainer","12":"Explainee"},"turn_num_tokens":{"0":8,"1":67,"2":78,"3":83,"4":155,"5":42,"6":39,"7":78,"8":73,"9":8,"10":43,"11":29,"12":108},"turn":{"0":"ELI5 - Halting Problem and the Self-Referential Proof","1":"There is no moving last, because M sees the whole of P when it makes its decision- the point is the notion of M is logically inconsistent to begin with.  If I came up to you, and said \"I know for a fact the next thing you'll say is 'bananas'\", and you say \"potatoes\", that's not you cheating, thats the original supposition being wrong in the first place","2":"I guess, at the highest level, I'm having a hard time seeing how P works--there are too many inputs and moving parts for me to comprehend.  M--when taken on its own--is simple enough to understand; it takes a program and a set of inputs and evaluates, based on the inputs, whether the program will halt or continue forever.    How does P figure into this?  There are just too many layers to make sense of, perhaps?","3":"P is what we use to show that M is logically inconsistent. You cannot have a program that it always right if you can construct a scenario that it is wrong for.  If this is something you're interested in, but haven't really come across before, I'd recommend reading into proof by contradiction some more. This isn't the easiest example of a proof by contradiction, so trying to figure out the logic of the argument as well as the programs might be what's confusing you","4":"The overarching logic makes sense to me--we posit that there's a program (call it the \"Perfect Decider\") that can correctly determine whether, for **any** **possible program that could ever exist**, halts or instead runs indefinitely.  Then we invent another program (the \"Nasty Trickster\")--deliberately designing it to fool the Perfect Decider--and show that, when the Perfect Decider is fed to the Nasty Trickster (or perhaps vice versa - that's something that I don't understand and seems convoluted to me), the Perfect Decider doesn't work as advertised.    Thus, because of the existence of at least one counterexample, there can't be such a thing as the Perfect Decider (i.e., there can't be a program that can correctly determine, for any possible program that could ever exist, halts or instead runs forever).  That does not rule out the possibility of Very, Very Good Deciders, but it does show that a Perfect Decider is a logical impossibility.","5":"I think what you're misunderstanding is that P is not cheating M. If a perfect decider was possible, it would be able to deal with *any* program, even one where P 'moved last', but clearly this is impossible, so it cannot exist","6":"There is still something unsatisfying with permitting P to evaluate M and then change its answer.  That seems to bending the spirit, if not the rules, of the thought exercise.  Do you see where I\u2019m coming from?","7":"I see where you're coming from, but you're not really thinking about it in the right way. it isn't evaluating M and then changing, the program is already written and doesn't change at all. M can see the entire program from the get go, and makes its decision taking into account the fact that P can choose to go on forever or stop, it just can never get the right answer, hence why a perfect decider can't exist.","8":"Is there an alternative explanation of P from the HuffPo article that might make clear how P works and doesn\u2019t \u201ccheat l\u201d?  I understand M when it stands alone (i.e., at a high enough level of abstraction away, I can grok how it takes a program and input to a program and declares whether the program will half or not given that input).  What I don\u2019t get is how P works.","9":"I don't think there really is another way.","10":"Are there any alternative explanations where the manner in which P works is explained in a step by step fashion to someone who doesn\u2019t know how to program?  The HuffPo article, in my opinion, is not actually comprehensible to an average teenager.","11":"the problem is computing based at it's core, i think some understanding of how to read psuedo code is going to be essential regardless of how you explain it","12":"I tend to agree--and it's especially frustrating that the explanation is pitched to teenagers (who, admittedly, can be quite intelligent) but after going to a whole lot of trouble to \"dumb down\" the introduction, launches into a rather complicated explanation of P that assumes a ton of background knowledge.    Guess the HuffPo article\/explanation reminds me of why I largely disliked math textbooks growing up - they go out of their way to provide only trivial examples and then pretend that the hard stuff can simply be worked out from first principles.  Perhaps that would be so for Leibniz or Ramanujan, but not most of the world!"}}